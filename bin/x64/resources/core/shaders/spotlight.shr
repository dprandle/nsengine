type:<nsstring>nsspot_light_shader</nsstring>
vertex.type:<uint32>35633</uint32>
vertex.source:<nsstring>#version 440
layout (location = 0) in vec3 position;

uniform mat4 transform;
uniform mat4 projCamMat;
uniform mat4 nodeTransform;

void main()
{
	gl_Position = projCamMat * transform * nodeTransform * vec4(position, 1.0);
}


</nsstring>
geometry.type:<uint32>36313</uint32>
geometry.source:<nsstring></nsstring>
fragment.type:<uint32>35632</uint32>
fragment.source:<nsstring>#version 440

out vec4 fragColor;

struct SpotLight
{
	float ambientIntensity;
	float diffuseIntensity;
	vec3 color;
	vec3 position;
	float attConstant;
	float attLinear;
	float attExp;
	float shadowDarkness;
	vec3 direction;
	float cutoff;
};

struct Material
{
	float specPower;
	float specIntensity;
	vec3 specColor;
};

uniform sampler2DShadow shadowMap;
uniform sampler2D gWorldPosMap;
uniform sampler2D gDiffuseMap;
uniform sampler2D gNormalMap;
uniform sampler2D gMatMap;

uniform SpotLight light;
uniform vec2 screenSize;
uniform vec3 camWorldPos;
uniform mat4 projLightMat;
uniform vec2 shadowTexSize;
uniform int shadowSamples;
uniform bool castShadows;
uniform float epsilon;

float getShadowFactor(vec4 worldPos)
{
	vec4 lightPos = projLightMat * worldPos;
	vec3 wPos = worldPos.xyz;
	vec3 coords = lightPos.xyz / lightPos.w;
	vec3 uvCoords;
	uvCoords.x = 0.5 * coords.x + 0.5;
	uvCoords.y = 0.5 * coords.y + 0.5;
	uvCoords.z = 0.5 * coords.z + 0.5 - epsilon*8;

	if (shadowSamples == 0)
		return texture(shadowMap, uvCoords);

	int negBoundary = shadowSamples * -1;

	float total = 0.0;
	float xDelta = 1.0 / shadowTexSize.x;
	float yDelta = 1.0 / shadowTexSize.y;

	for (int i = negBoundary; i <= shadowSamples; ++i)
	{
		for (int j = negBoundary; j <= shadowSamples; ++j)
		{
			vec3 delta = vec3(j*xDelta,i*yDelta, 0.0);
			total += texture(shadowMap, uvCoords + delta);
		}
	}

    return total / ( (2*shadowSamples + 1) * (2*shadowSamples+1) );
}

vec2 getTexCoord()
{
   return gl_FragCoord.xy / screenSize;
}

vec4 getLightInfluence(vec4 lWorldPos, vec3 norm, Material pMat)
{
	vec3 worldPos = lWorldPos.xyz;
	vec3 lightDirection = normalize(light.direction); // used just for spot light attenuation

	vec3 lightToPixel = worldPos - light.position;
	float distance = length(lightToPixel);
	lightToPixel = normalize(lightToPixel);

	float spotFactor = dot(lightToPixel, lightDirection);
	float shadowFactor = 1.0;
	if (castShadows)
		shadowFactor = getShadowFactor(lWorldPos);

	if (spotFactor > light.cutoff)
	{
		vec4 ambientColor = vec4(light.color, 1.0f) * light.ambientIntensity;
		float diffuseFactor = dot(norm, -lightToPixel);

		vec4 diffuseColor  = vec4(0, 0, 0, 0);
		vec4 specularColor = vec4(0, 0, 0, 0);

		if (diffuseFactor > 0) 
		{
			diffuseColor = vec4(light.color, 1.0f) * light.diffuseIntensity * diffuseFactor;
			vec3 vertexToEye = normalize(camWorldPos - worldPos);
			vec3 lightReflect = normalize(reflect(lightToPixel, norm));
			float specularFactor = dot(vertexToEye, lightReflect);
			specularFactor = pow(specularFactor, pMat.specPower);
			if (specularFactor > 0)
			{
				specularColor = vec4(light.color, 1.0f) * pMat.specIntensity * specularFactor;
			}
		}

		vec4 color = ambientColor + shadowFactor*(diffuseColor + specularColor);

		// light attenuation
		float attenuation = 1.0f / (light.attConstant + light.attLinear * distance + light.attExp * distance * distance);
		color *= attenuation;

		// Spot light attenuation formula
		return color * ( 1.0 - ( (1.0 - spotFactor) / (1.0 - light.cutoff) ) );
	}
	else
	{
		return vec4(0,0,0,0);
	}
}

void main()
{
	vec2 texCoord = getTexCoord();
    vec4 worldPos = texture(gWorldPosMap, texCoord);
    vec4 color = texture(gDiffuseMap, texCoord);
    vec4 normal = texture(gNormalMap, texCoord);
	vec4 spec = texture(gMatMap, texCoord);

	Material material;
	material.specColor = spec.xyz;
	material.specIntensity = spec.a;
	material.specPower = normal.a;

	fragColor = vec4(color.rgb, 1.0) * getLightInfluence(worldPos, normal.xyz, material);
}


</nsstring>
