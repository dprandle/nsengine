@#$SHADER@#$
1.0.0
FRAGMENT BEGIN
tkpreview.fsh
#version 440

in vec2 texCoords;
in vec3 normal;
in vec3 tangent;
in vec4 worldPos4;

struct Material
{
	float specPower;
	float specIntensity;
	vec3 specColor;
};

struct DirectionLight 
{
	float ambientIntensity;
	float diffuseIntensity;
	vec3 direction;
	vec3 color;
};

uniform sampler2D diffuseMap;
uniform sampler2D normalMap;

uniform Material mat;
uniform DirectionLight light;
uniform vec3 camWorldPos;

uniform bool colorMode;
uniform vec4 fragColOut;

uniform bool hasDiffuseMap = false;
uniform bool hasNormalMap = false;

layout (location = 0) out vec4 colorOut;


vec4 getLightInfluence(vec3 norm)
{
	vec3 worldPos = worldPos4.xyz;

	vec4 ambientColor = vec4(light.color, 1.0f) * light.ambientIntensity;
	float diffuseFactor = dot(norm,-light.direction);

	vec4 diffuseColor  = vec4(0.0, 0.0, 0.0, 0.0);
	vec4 specularColor = vec4(0.0, 0.0, 0.0, 0.0);

	if (diffuseFactor > 0) 
	{
		diffuseColor = vec4(light.color, 1.0f) * light.diffuseIntensity * diffuseFactor;
        vec3 vertexToEye = normalize(camWorldPos - worldPos);
        vec3 lightReflect = normalize(reflect(vec3(0,0,-1),norm));

        float specularFactor = dot(vertexToEye, lightReflect);
		specularFactor = pow(specularFactor, 2);
		if (specularFactor > 0)
			specularColor = vec4(mat.specColor, 1.0f) * mat.specIntensity * specularFactor;
	}

	return ambientColor + specularColor + diffuseColor;
}

vec3 calculateNormalMap()
{
    vec3 norm = normalize(normal);
	if (!colorMode && hasNormalMap)
	{
		vec3 tang = normalize(tangent);
		tang = normalize(tang - dot(tang, norm) * norm);
		vec3 biTangent = cross(tang, norm);
		vec3 bmNormal = texture(normalMap, texCoords).xyz;
		bmNormal = 2.0 * bmNormal - vec3(1.0, 1.0, 1.0);
		vec3 nNormal;
		mat3 transBumpMap = mat3(tang, biTangent, norm);
		nNormal = transBumpMap * bmNormal;
		nNormal = normalize(nNormal);
		return nNormal;
	}
	return norm;
}


void main()
{
	vec4 difCol = fragColOut;
	if (!colorMode && hasDiffuseMap)
		difCol = texture(diffuseMap, texCoords);

	vec4 lightingVec = difCol * getLightInfluence(calculateNormalMap());
	colorOut = vec4(lightingVec.xyz,1.0);
}
FRAGMENT END
VERTEX BEGIN
tkpreview.vsh
#version 440

layout (location = 0) in vec3 position;
layout (location = 1) in vec2 tex;
layout (location = 2) in vec3 norm;
layout (location = 3) in vec3 tang;

uniform mat4 nodeTransform;
uniform mat4 projCamMat;
uniform mat4 transform;

out vec2 texCoords;
out vec3 normal;
out vec3 tangent;
out vec4 worldPos4;

void main()
{
	normal = (transform * nodeTransform * vec4(norm, 0.0)).xyz;
	tangent = (transform * nodeTransform * vec4(tang, 0.0)).xyz;
	worldPos4 = transform * nodeTransform * vec4(position, 1.0);
	texCoords = tex;
    gl_Position = projCamMat * worldPos4;
}
VERTEX END
SHADER END
