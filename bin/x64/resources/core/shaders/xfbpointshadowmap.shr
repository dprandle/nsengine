type:<nsstring>nspoint_shadowmap_xfb_shader</nsstring>
vertex.type:<uint32>35633</uint32>
vertex.source:<nsstring>#version 440

layout (location = 0) in vec3 worldPosIn;
layout (location = 1) in vec3 texIn;
layout (location = 2) in vec3 normIn;
layout (location = 3) in vec3 tangIn;

uniform mat4 projLightMat;

out vec4 worldPos;
out vec2 texCoords;
out vec3 normal;
out vec3 tangent;
flat out uint refID;

void main()
{

	worldPos = vec4(worldPosIn, 1.0);
	texCoords = texIn.xy;
	normal = normIn;
	tangent = tangIn;
	refID = uint(texIn.z);
	gl_Position = projLightMat * worldPos;
} 


</nsstring>
geometry.type:<uint32>36313</uint32>
geometry.source:<nsstring>#version 440

layout (triangles) in;
layout (triangle_strip, max_vertices = 18) out;
uniform mat4 projMat;
uniform mat4 inverseTMat;
out vec4 worldPos;

mat4 views[6];

void main()
{
	views[0][0] = vec4( 0,  0,  1,  0);
	views[0][1] = vec4( 0, -1,  0,  0);
	views[0][2] = vec4(-1,  0,  0,  0);
	views[0][3] = vec4( 0,  0,  0,  1);

	views[1][0] = vec4( 0,  0, -1,  0);
	views[1][1] = vec4( 0, -1,  0,  0);
	views[1][2] = vec4( 1,  0,  0,  0);
	views[1][3] = vec4( 0,  0,  0,  1);

	views[2][0] = vec4( 1,  0,  0,  0);
	views[2][1] = vec4( 0,  0,  1,  0);
	views[2][2] = vec4( 0,  1,  0,  0);
	views[2][3] = vec4( 0,  0,  0,  1);

	views[3][0] = vec4( 1,  0,  0,  0);
	views[3][1] = vec4( 0,  0, -1,  0);
	views[3][2] = vec4( 0, -1,  0,  0);
	views[3][3] = vec4( 0,  0,  0,  1);

	views[4][0] = vec4( 1,  0,  0,  0);
	views[4][1] = vec4( 0, -1,  0,  0);
	views[4][2] = vec4( 0,  0,  1,  0);
	views[4][3] = vec4( 0,  0,  0,  1);

	views[5][0] = vec4(-1,  0,  0,  0);
	views[5][1] = vec4( 0, -1,  0,  0);
	views[5][2] = vec4( 0,  0, -1,  0);
	views[5][3] = vec4( 0,  0,  0,  1);

	for (gl_Layer = 0; gl_Layer < 6; ++gl_Layer)
	{
		for (int vertIndex = 0; vertIndex < 3; ++vertIndex)
		{
			worldPos = gl_in[vertIndex].gl_Position;
			gl_Position = projMat * views[gl_Layer] * inverseTMat * worldPos;
			EmitVertex();
		}
		EndPrimitive();
	}
}


</nsstring>
fragment.type:<uint32>35632</uint32>
fragment.source:<nsstring>#version 440

uniform vec3 lightPos;
uniform float maxDepth;
in vec4 worldPos;

void main()
{
	gl_FragDepth = length(worldPos.xyz - lightPos) / maxDepth;
}



</nsstring>
